classdef LBSD < handle
    %LBSD An instance of this class represents a Lane Based Strategic
    %   Deconfliction Supplemental Data Service Provider (SDSP). The user
    %   of this class is expected to create the lane_graph (which is a
    %   public property of this object), a directed graph as defined by 
    %   matlab (see https://www.mathworks.com/help/matlab/ref/digraph.html)
    %
    %   When constructing new lane graphs for this object, it is important
    %   to make the vertexes and edges indexed by a string, rather than just
    %   an integer. This makes the lane structure more flexible, allowing
    %   lanes to be added and deleted dynamically. The indexes can be set
    %   to strings by building a table with 'RowNames' specified.
    %   (see
    %   https://www.mathworks.com/help/matlab/matlab_prog/access-data-in-a-table.html).
    %   Additionally, the lane_graph must have XData, YData, ZData, as well
    %   as boolean Land and Launch columns. See the lane_graph generated by
    %   LBSD.genSampleLanes for an example.
    %   
    %   When the lane_graph property is set, this class
    %   automatically calculates delauney triangulations of land and launch
    %   nodes to facilitate nearest neigbor searching.
    %
    %   A sample graph can be generated by calling the static function 
    %   genSampleLanes. For example:
    %       
    %       lbsd = LBSD.genSampleLanes(10, 15)
    %
    %   For documentation of this function run:
    %
    %       help LBSD.genSampleLanes
    %
    %   For general documentation of this class, run:
    %
    %       help LBSD
    %
    %   Author:
    %       D. Sacharny
    %       UU
    %       Summer 2021
    %
    
    properties
        % A digraph representing the lane network. 
        lane_graph
    end
    
    properties (Access = protected)
        % A table of reservations. This table is preallocated for 
        % for performance reasons. To get the total number of reservations, 
        % use the getNumReservations method. This table contains the 
        % following columns:
        %   id %(string): unique identifier for this reservation
        %   lane_id %(string): The lane that is being reserved
        %   entry_time_s %(float): entry time from the lane in seconds 
        %   exit_time_s %(float): exit time from the lane in seconds 
        %   speed %(float): speed in m/s
        %   hd %(float): required headway distance 
        reservations
        % The next id of a reservation
        next_res_id = 1
        % The number of rows to preallocate in the reservations table
        preallocate = 100000
        % The next row to write to in the reservations table
        next_tbl_row = 1
        % A Warning indicator if we have exhausted all preallocated
        % reservations rows.
        notified_preallocation_warning = false
        % The row of latest reservation that was recorded in the
        % reservations table
        latest_res_row
        % Array of subscribers to the NewReservation event
        new_res_listeners = []
        % The delauney triangulation of launch vertexes. This is used in
        % order to perform a nearest neighbor search
        launch_delauney_tri
        % The delauney triangulation of land vertexes. This is used in
        % order to perform a nearest neighbor search
        land_delauney_tri
        % Table of launch nodes
        launch_table
        % Table of land nodes
        land_table
    end
    
    events
        % This event is triggered when a new reservation is recorded, i.e.,
        % when a successful call to makeReservation is made. The event
        % handler can obtain the reservation that triggered this request by
        % calling getLatestRes.
        NewReservation
    end
    
    methods
        function obj = LBSD()
            %LBSD Construct an instance of this class
            obj.clearReservations();
        end

        %% Reservation Methods
        function subscribeToNewReservation(obj, subscriber)
            % subscribeToNewReservation Set an event listener to trigger  
            %   when a new reservation is made.
            % On input
            %   obj - an instance of the LBSD class
            %   subscriber - a function handle to trigger
            % Call:
            %   lbsd.subscribeToNewReservation(@atoc.handleNewRes);
            lh = obj.addlistener('NewReservation', subscriber);
            obj.new_res_listeners = [obj.new_res_listeners, lh];
        end
        
        function clearNewResSubscriptions(obj)
            % clearNewResSubscriptions Delete all subscriptions to the
            % NewReservation event
            for lh = obj.new_res_listeners
                delete(lh);
            end
        end
        
        function res = getLatestRes(obj)
            % getLatestRes Get the latest reservation that was made
            % On Output:
            %   res: single row table, or empty table if no reservations
            %   have been made.
            if isempty(obj.latest_res_row)
                res = obj.reservations(obj.reservations.id == -1);
            else
                res = obj.reservations(obj.latest_res_row,:);
            end
        end
        
        function num_res = getNumReservations(obj)
            % getNumReservations Get the reservations for a lane
            % On Input:
            %   lane_id: (string) the lane id
            % On Output:
            %   lane_res: a table containing reservations
            num_res = obj.next_tbl_row - 1;
        end
        
        function res = getReservations(obj)
            % getReservations Get all reservations
            % On Output:
            %   res: a table containing reservations
            res = obj.reservations(1:obj.next_tbl_row - 1,:);
        end
        
        function clearReservations(obj)
            % clearReservations Clear all reservations
            obj.reservations = table( 'Size',[obj.preallocate 6], ...
                'VariableNames', {'id','lane_id', ...
                'entry_time_s', 'exit_time_s', 'speed', 'hd'}, ...
                'VariableTypes',{'string','string','double','double', ...
                'double', 'double'} );
            obj.next_res_id = 1;
            obj.next_tbl_row = 1;
        end
        
        function [ok, res_id] = makeReservation(obj, lane_id, entry_time_s, ...
            exit_time_s, speed, hd)
            %makeReservation Create a reservation
            %   This method checks that the lane_id is valid and that the
            %   requested reservation does not overlap entry or exit time 
            %   within headway distance.
            %   On Input:
            %       lane_id %(string): The lane that is being reserved
            %       entry_time_s %(float): entry time from the lane in seconds 
            %       exit_time_s %(float): exit time from the lane in seconds 
            %       speed %(float): speed in m/s
            %       hd %(float): required headway distance 
            %   On Output:
            %       ok: true if the reservation was made successfully
            %       res_id: (string) reservation id. empty string if
            %       ok is false.
            %   Call:
            %       res = lbsd.makeReservation("1",0,10,10,10)
            %
            
            % First check that the lane_id exists
            if ~find(obj.lane_graph.Edges.Properties.RowNames == lane_id)
                ok = false;
                res_id = "";
            else
                % Create the candidate reservation row
                res = {string(obj.next_res_id), string(lane_id), ...
                        entry_time_s, exit_time_s, speed, hd};
                % Grab the reservations in this lane
                lane_res = obj.getLaneReservations(lane_id);
                if isempty(lane_res)
                    % No reservations in table, so go ahead and create a
                    % new one.
                    new_row_ind = obj.appendReservation(res);
                    obj.latest_res_row = new_row_ind;
                    res_id = obj.next_res_id;
                    obj.next_res_id = obj.next_res_id + 1;
                    ok = true;
                    notify(obj, 'NewReservation');
                else
                    % Check that entry time and exit times do not overlap
                    % by headway.
                    entry_time_conflict = find(...
                        abs(lane_res.('entry_time_s')-entry_time_s) < hd, ...
                        1);
                    exit_time_conflict = find(...
                        abs(lane_res.('exit_time_s')-exit_time_s) < hd, ...
                        1);
                    if isempty(entry_time_conflict) && ...
                            isempty(exit_time_conflict)
                        new_row_ind = obj.appendReservation(res);
                        obj.latest_res_row = new_row_ind;
                        res_id = obj.next_res_id;
                        obj.next_res_id = obj.next_res_id + 1;
                        ok = true;
                        notify(obj, 'NewReservation');
                    else
                        ok = false;
                        res_id = "";
                    end
                end
            end
        end
        
        function lane_res = getLaneReservations(obj, lane_id)
            % getLaneReservations Get the reservations for a lane
            % On Input:
            %   lane_id: (string) the lane id
            % On Output:
            %   lane_res: a table containing reservations
            lane_res = ...
                obj.reservations(obj.reservations.lane_id == lane_id,:);
        end
        
        function genRandReservations(obj, start_time, end_time, num_res, ...
                lane_ids, speed, headway)
            % genRandReservations create some random reservations
            % On Input:
            %   start_time: (float) the earliest reservation in seconds
            %   end_time: (float) the latest reservation in seconds
            %   num_res: (integer) the total number of reservations to try.
            %       Note: The final number of successful reservations may be
            %       less due to headway constraints.
            %   lane_ids: nx1 string array of lane ids to schedule on
            %   speed: (float) m/s
            %   headway: (float) m
            hd = headway;
            lengths = obj.getLaneLengths(lane_ids);
            entry_times = start_time + ...
                (end_time-start_time)*rand(1, num_res);
            for lane = lane_ids
                for res = 1:num_res
                    l = lengths(lane_ids==lane);
                    exit_time = entry_times(res)+l/speed;
                    [ok, ~] = obj.makeReservation(lane, entry_times(res), ...
                        exit_time, speed, hd);
                end
            end
        end
        
              
        %% Spatial Network measures
        bc = LEM_SNM_betweenness_centrality_node(obj)
        [acc,avg_acc] = LEM_SNM_accessibility(obj)
        alpha_index = LEM_SNM_alpha_index(obj)
        c = LEM_SNM_cyclomatic_num(obj)
        coefs = LEM_SNM_clustering_coefs(obj)
        [cost_L_T,cost_L_MST,cost] = LEM_SNM_cost_L_T(obj)
        degrees = LEM_SNM_degree(obj)
        density = LEM_SNM_density(obj)
        detour_index = LEM_SNM_detour_index(obj)
        e = LEM_SNM_efficiency(obj)
        gamma_index = LEM_SNM_gamma_index(obj)
        diameter = LEM_SNM_graph_diameter(obj)
        r_n = LEM_SNM_r_n(obj)
        total_length = LEM_SNM_total_length(obj)
        
        % Road Methods
        function roads = LEM_gen_grid_roads(obj,xmin,xmax,ymin,ymax,dx,dy)
            % LEM_gen_grid_roads - generate roads using grid layout
            % On input:
            %     xmin (float): min x coord
            %     xmax (float): max x coord
            %     ymin (float): min y coord
            %     ymax (float): max y coord
            %     dx (float): dx space between vertexes
            %     dy (float): dy space between vertexes
            % On output:
            %     roads (road struct): road info
            %       .vertexes (nx3 array): x,y,z coords of endpoints
            %       .edges (mx2 array): indexes of vertexes defining lanes
            % Call:
            %     roadsg = LEM_gen_grid_roads(-20,20,-20,20,5,5);
            % Author:
            %    T. Henderson
            %    UU
            %    Fall 2020
            %
            
            x_vals = [xmin:dx:xmax]';
            y_vals = [ymin:dy:ymax]';
            num_x_vals = length(x_vals);
            num_y_vals = length(y_vals);
            num_vertexes = num_x_vals*num_y_vals;
            vertexes = zeros(num_vertexes,3);
            count = 0;
            for ind1 = 1:num_x_vals
                x = x_vals(ind1);
                for ind2 = 1:num_y_vals
                    count = count + 1;
                    y = y_vals(ind2);
                    vertexes(count,1:2) = [x,y];
                end
            end
            
            edges = [];
            for ind1 = 1:num_vertexes-1
                pt1 = vertexes(ind1,:);
                for ind2 = ind1+1:num_vertexes
                    pt2 = vertexes(ind2,:);
                    if norm(pt2-pt1)<1.1*dx|norm(pt2-pt1)<1.1*dy
                        edges = [edges;ind1,ind2];
                    end
                end
            end
            roads.vertexes = vertexes;
            roads.edges = edges;
            
            tch = 0;
        end
        
        function airways = LEM_gen_airways(obj,roads,launch_sites,...
                land_sites,min_lane_len,altitude1,altitude2)
            % LEM_gen_airways - generate airway lanes from a road network
            % On input:
            %     roads (road struct): road info
            %     launch_site (1xm vector): vertex indexes of launch locations
            %     land_sites (1xn vector): vertex indexes of lan locations
            % On output:
            %     airways (airway struct): lane information
            % Call:
            %     lanes_SLC = LEM_gen_airways(roads_SLC,launch_SLC, land_SLC);
            % Author:
            %     T. Henderson
            %     UU
            %     Fall 2020
            %
            
            airways = roads;
            airways.vertexes(:,3) = 0;
            
            num_vertexes = length(airways.vertexes(:,1));
            
            airways.launch_vertexes = launch_sites;
            airways.land_vertexes = land_sites;
            airways.min_lane_len = min_lane_len;
            airways.g_z_upper = altitude2; %534
            airways.g_z_lower = altitude1; %467
            
            airways = LBSD.LEM_gen_lanes(obj,airways);
            airways.vertexes = roads.vertexes;
            airways = LBSD.LEM_add_ground_height(obj,airways);
        end
        
        %% Lane Methods
            
            function set.lane_graph(obj, g)
                % set.lane_graph Set the lane_graph property
            % 	In addition to checking all the required columns are there,
            % 	this method generates delauney triagulations for land and
            % 	launch nodes.
            % On Input:
            %   g - the lane graph - a directed graph
            has_x = any(startsWith(strtrim(...
                g.Nodes.Properties.VariableNames), 'XData'));
            has_y = any(startsWith(strtrim(...
                g.Nodes.Properties.VariableNames), 'YData'));
            has_z = any(startsWith(strtrim(...
                g.Nodes.Properties.VariableNames), 'ZData'));
            has_land = any(startsWith(strtrim(...
                g.Nodes.Properties.VariableNames), 'Land'));
            has_launch = any(startsWith(strtrim(...
                g.Nodes.Properties.VariableNames), 'Launch'));
            
            if ~has_x
                error('lane_graph must have XData column');
            end
            if ~has_y
                error('lane_graph must have YData column');
            end
            if ~has_z
                error('lane_graph must have ZData column');
            end
            if ~has_land
                error('lane_graph must have Land column');
            end
            if ~has_launch
                error('lane_graph must have Launch column');
            end
            
            obj.lane_graph = g;
            obj.recalcInternalStructs();
        end
        
        function h = plot(obj)
            %plot Plot the Lane System
            xdata = obj.lane_graph.Nodes.XData;
            ydata = obj.lane_graph.Nodes.YData;
            zdata = obj.lane_graph.Nodes.ZData;
            h = plot(obj.lane_graph,'XData',xdata,'YData',ydata, ...
                'ZData',zdata);
        end
        
        function highlight(obj, h, lane_ids, varargin)
            % highlight Highlight lanes in plotted graph
            % On Input:
            %   h - plot handle returned from LBSD.plot
            %   lane_ids - (nx1 string array) lane_ids
            %   varargin - (optional) variable arguments passed directly to
            %       matlab's highlight method
            %   (see
            %   https://www.mathworks.com/help/matlab/ref/matlab.graphics.chart.primitive.graphplot.highlight.html)
            
            inds = find(ismember(...
                obj.lane_graph.Edges.Properties.RowNames, lane_ids));
            highlight(h,'Edges',inds,varargin{:});
        end
        
        function ids = getClosestLaunchVerts(obj, q)
            % getClosestLaunchVerts Get the Vertex IDs of the closest launch
            % nodes. 
            % On Input:
            %   q - nx2 query points. Each row is [x,y]
            % On Output:
            %   ids - (nx1 string array) ids of the closest launch vertex
            % Call:
            %   ids = lbsd.getClosestLaunchVerts([0 0; 5 5; -30 -15])
            xi = nearestNeighbor(obj.launch_delauney_tri, q);
            ids = string(obj.launch_table.Properties.RowNames(xi));
        end
        
        function ids = getClosestLandVerts(obj, q)
            % getClosestLandVerts Get the Vertex IDs of the closest land
            % nodes. 
            % On Input:
            %   q - nx2 query points. Each row is [x,y]
            % On Output:
            %   ids - (nx1 string array) ids of the closest launch vertex
            % Call:
            %   ids = lbsd.getClosestLandVerts([0 0; 5 5; -30 -15])
            xi = nearestNeighbor(obj.land_delauney_tri, q);
            ids = string(obj.land_table.Properties.RowNames(xi));
        end
        
        function [lane_ids, vert_ids, dist] = getShortestPath(obj, ...
                start_vert_id, end_vert_id)
            % getShortestPath Get a shortest path between two vertexes 
            % On Input:
            %   start_vert_id - (string) the id of the start vertex
            %   end_vert_id - (string) the id of the end vertex
            % On Output:
            %   lane_ids - (nx1 string array) ids of lanes from start to
            %       end.
            %   vert_ids - (nx1 string array) ids of the vertexes from
            %       start to end
            %   distance - the distance covered by the path
            % Call:
            %   [lane_ids, vert_ids, dist] = lbsd.getShortestPath("12","22")
            [vert_ids,dist,lane_ids] = shortestpath(obj.lane_graph, ...
                start_vert_id, end_vert_id);
            lane_ids = string(obj.lane_graph.Edges.Properties.RowNames(...
                lane_ids));
            vert_ids = vert_ids';
        end
        
        function ids = getLaunchVerts(obj)
            % getLaunchVerts Get the Vertex IDs of the launch nodes
            % On Output:
            %   ids - indices of vertexes
            ids = string(obj.launch_table.Properties.RowNames);
        end
        
        function ids = getLandVerts(obj)
            % getLandVerts Get the Vertex IDs of the land nodes
            % On Output:
            %   ids - string array
            ids = string(obj.land_table.Properties.RowNames);
        end
        
        function positions = getVertPositions(obj, ids)
            % getVertPositions Get the Positions of Vertexes in the lane 
            %   system by ID
            % On Input:
            %   ids - nx1 string array or ':' for all
            % On Output:
            %   positions - nx3 positions of vertexes
            positions = obj.lane_graph.Nodes{ids,{'XData','YData','ZData'}};
        end
        
        function ids = getLaneVertexes(obj, lane_id)
            % getLaneVertexes Get the vertex ids that define the lane
            % endpoints.
            % On Input:
            %   lane_id - (string) the id of the lane
            % On Output:
            %   ids - 2x1 string array of endpoint vertex ids
            rows = obj.lane_graph.Edges{lane_id,{'EndNodes'}}';
            ids = string(obj.lane_graph.Edges(rows,:).Properties.RowNames);
        end
        
        function lane_ids = getLaneIds(obj)
            % getLaneIds Get the vertex ids that define the lane
            % endpoints.
            % On Output:
            %   lane_ids - nx1 vector of strings of lane ids
            lane_ids = obj.lane_graph.Edges.Properties.RowNames;
            lane_ids = string(lane_ids);
        end
        
        function lengths = getLaneLengths(obj, lane_ids)
            % getLaneLengths Get the langths of lanes
            % On Input:
            %   lane_ids - nx1 (strings) the ids of the lanes
            % On Output:
            %   length - nx1 vector of floats of distances
            % Call:
            %   lengths = lbsd.getLaneLengths([1])
            num_ids = length(lane_ids);
            lengths = zeros(num_ids,1);
            for i = 1:num_ids
                lane_id = lane_ids(i);
                vert_ids = obj.lane_graph.Edges{ lane_id, {'EndNodes'} };
                vert_x = obj.getVertPositions(vert_ids);
                d = norm(vert_x(2,:) - vert_x(1,:));
                lengths(i) = d;
            end
        end
        
        function recalcInternalStructs(obj)
            % recalcInternalStructs Recalculate internal structures
            %   This function recalculates internal structures like land
            %   and launch tables and delauney triangulations. This
            %   method should be called anytime the lane_graph is modified.
            obj.recalcLaunchTable();
            obj.recalcLandTable();
            obj.recalcLaunchDelauney();
            obj.recalcLandDelauney();
        end
    end
    
    methods (Access = protected)
        function row_ind = appendReservation(obj, row)
            % appendReservation Append to the reservations table
            % On Input:
            %   row - cell array containing the reservation 
            % On Output:
            %   row_ind - the index of the new row in the reservations
            %   table.
            if obj.next_tbl_row < obj.preallocate
                obj.reservations(obj.next_tbl_row, :) = row;
                row_ind = obj.next_tbl_row;
                obj.next_tbl_row = obj.next_tbl_row + 1;
            else
                if ~obj.notified_preallocation_warning
                    warning("Exhausted Preallocated Reservations, Performance will now suffer");
                    obj.notified_preallocation_warning = true;
                end
                obj.reservations = [obj.reservations; row];
                row_ind = obj.next_tbl_row;
                obj.next_tbl_row = obj.next_tbl_row + 1;
            end
        end
        
                
        function recalcLaunchDelauney(obj)
            % recalcLaunchDelauney Recalculate the delauney triangulation
            % for launch nodes
            P = obj.launch_table{:, {'XData','YData'}};
            obj.launch_delauney_tri = delaunayTriangulation(P);
        end
        
        function recalcLandDelauney(obj)
            % recalcLandDelauney Recalculate the delauney triangulation
            % for land nodes
            P = obj.land_table{:, {'XData','YData'}};
            obj.land_delauney_tri = delaunayTriangulation(P);
        end
        
        function recalcLaunchTable(obj)
            % recalcLaunchTable Recalculate the launch node table
            obj.launch_table = obj.lane_graph.Nodes(...
                obj.lane_graph.Nodes.Launch==1,:);
        end
        
        function recalcLandTable(obj)
            % recalcLandTable Recalculate the land node table
            obj.land_table = obj.lane_graph.Nodes(...
                obj.lane_graph.Nodes.Land==1,:);
        end
    end
    
    methods (Static)
        lbsd = genSampleLanes(lane_length_m, altitude_m)
        f = LEM_SNM_route_factor(obj)
        ds = LEM_SNM_min_path_step(obj)
        dd = LEM_SNM_min_path_dist(obj)
        A = LEM_SNM_adjacency_matrix(obj)
        airways_out = LEM_gen_lanes(obj,airways)
        [r_up,r_dn] = LEM_roundabout(obj,airways,v)
        ptheta = LEM_posori(obj,theta)
        pts_out = LEM_elim_redundant(obj,pts)
        G = LEM_airways2graph(obj,airways)
        airways_out = LEM_add_ground_height(obj,airways)
        LEM_show_airways3D(obj,airways,path)
        t = LEM_launch_time_nc(obj,reservations,path,t1,t2,lane_lengths,hd)
        LEM_test_res
        excluded_out = LEM_excluded(obj,excluded,t1,t2,ft1,ft2,ht)
        new_int = LEM_merge_excluded(obj,t1,t2,int1,int2)
        lanes = LEM_vertexes2lanes(obj,airways,indexes)
        [path,v_path] = LEM_get_path(obj,airways,v1,v2,props)
        [reservations_out,flights] = LEM_gen_reservations(obj,airways,...
            a_flights,reservations,request,n,hd)
        requests = LEM_gen_requests_packed(obj,t_min,t_max,airways,...
            num_requests,del_t,speeds)
        route = LEM_plan2route(obj,plan,airways)
        requests = LEM_gen_requests_LBSD(obj,t_min,t_max,airways,...
            num_requests,launch_interval,speeds)
        P = LEM_performance(obj,flights)
        LEM_run_flights(obj,airways,flights,a_on,del_t,fname)
        flight_out = LEM_gen_traj(obj,flight,del_t)
        [reservations,flights] = LEM_requests2reservations(obj,airways,...
            requests,hd)
        [flight_plan,reservations] = LEM_reserve_fp(obj,reservations,...
            airways,t1,t2,speed,path,hd)
        res = LEM_sim1_LBSD_51x51(obj,num_flights,airways,t_min,t_max,...
            launch_time_spread,b)
        indexes = LEM_find_conflict(obj,reservations,ht)
    end
end

