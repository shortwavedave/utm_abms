classdef LBSD < handle
    %LBSD An instance of this class represents a Lane Based Strategic
    %   Deconfliction Supplemental Data Service Provider (SDSP). The user
    %   of this class is expected to create the lane_graph (which is a
    %   public property of this object), a directed graph as defined by 
    %   matlab (see https://www.mathworks.com/help/matlab/ref/digraph.html)
    %
    %   When constructing new lane graphs for this object, it is important
    %   to make the vertexes and edges indexed by a string, rather than just
    %   an integer. This makes the lane structure more flexible, allowing
    %   lanes to be added and deleted dynamically. The indexes can be set
    %   to strings by building a table with 'RowNames' specified.
    %   (see
    %   https://www.mathworks.com/help/matlab/matlab_prog/access-data-in-a-table.html).
    %   Additionally, the lane_graph must have XData, YData, ZData, as well
    %   as boolean Land and Launch columns. See the lane_graph generated by
    %   LBSD.genSampleLanes for an example.
    %   
    %   When the lane_graph property is set, this class
    %   automatically calculates delauney triangulations of land and launch
    %   nodes to facilitate nearest neigbor searching.
    %
    %   A sample graph can be generated by calling the static function 
    %   genSampleLanes. For example:
    %       
    %       lbsd = LBSD.genSampleLanes(10, 15)
    %
    %   For documentation of this function run:
    %
    %       help LBSD.genSampleLanes
    %
    %   For general documentation of this class, run:
    %
    %       help LBSD
    %
    %   Authors:
    %       D. Sacharny
    %       T. Henderson
    %       V. Marston
    %       UU
    %       Summer 2021
    %
    
    properties
        % A digraph representing the lane network. 
        lane_graph
        % A undirected graph representing a ground network
        road_graph
        
    end
    
    properties (Access = protected)
        % A table of reservations. This table is preallocated for 
        % for performance reasons. To get the total number of reservations, 
        % use the getNumReservations method. This table contains the 
        % following columns:
        %   id %(string): unique identifier for this reservation
        %   lane_id %(string): The lane that is being reserved
        %   entry_time_s %(float): entry time from the lane in seconds 
        %   exit_time_s %(float): exit time from the lane in seconds 
        %   speed %(float): speed in m/s
        %   hd %(float): required headway distance 
        reservations
        % The next id of a reservation
        next_res_id = 1
        % The number of rows to preallocate in the reservations table
        preallocate = 100000
        % The next row to write to in the reservations table
        next_tbl_row = 1
        % A Warning indicator if we have exhausted all preallocated
        % reservations rows.
        notified_preallocation_warning = false
        % The row of latest reservation that was recorded in the
        % reservations table
        latest_res_row
        % Array of subscribers to the NewReservation event
        new_res_listeners = []
        % The delauney triangulation of launch vertexes. This is used in
        % order to perform a nearest neighbor search
        launch_delauney_tri
        % The delauney triangulation of land vertexes. This is used in
        % order to perform a nearest neighbor search
        land_delauney_tri
        % Table of launch nodes
        launch_table
        % Table of land nodes
        land_table
        % Cached table of edges
        edge_table
        % Cached table of nodes
        node_table
        % Cached shortest paths
        path_cache
        % Cache map for the path_cache
        path_cache_map
    end
    
    events
        % This event is triggered when a new reservation is recorded, i.e.,
        % when a successful call to makeReservation is made. The event
        % handler can obtain the reservation that triggered this request by
        % calling getLatestRes.
        NewReservation
    end
    
    methods
        function obj = LBSD()
            %LBSD Construct an instance of this class
            obj.clearReservations();
        end

        %% Reservation Methods
        [d, n] = getLaneOccupancy(obj, lane_id, t0, tf)
        
        function subscribeToNewReservation(obj, subscriber)
            % subscribeToNewReservation Set an event listener to trigger  
            %   when a new reservation is made.
            % On input/
            %   obj - an instance of the LBSD class
            %   subscriber - a function handle to trigger
            % Call:
            %   lbsd.subscribeToNewReservation(@atoc.handleNewRes);
            lh = obj.addlistener('NewReservation', subscriber);
            obj.new_res_listeners = [obj.new_res_listeners, lh];
        end
        
        function clearNewResSubscriptions(obj)
            % clearNewResSubscriptions Delete all subscriptions to the
            % NewReservation event
            for lh = obj.new_res_listeners
                delete(lh);
            end
        end
        
        function res = getLatestRes(obj)
            % getLatestRes Get the latest reservation that was made
            % On Output:
            %   res: single row table, or empty table if no reservations
            %   have been made.
            if isempty(obj.latest_res_row)
                res = obj.reservations(obj.reservations.id == -1);
            else
                res = obj.reservations(obj.latest_res_row,:);
            end
        end
        
        function num_res = getNumReservations(obj)
            % getNumReservations Get the reservations for a lane
            % On Input:
            %   lane_id: (string) the lane id
            % On Output:
            %   lane_res: a table containing reservations
            num_res = obj.next_tbl_row - 1;
        end
        
        function res = getReservations(obj)
            % getReservations Get all reservations
            % On Output:
            %   res: a table containing reservations
            res = obj.reservations(1:obj.next_tbl_row - 1,:);
        end
        
        function lane_id = getLaneIdFromResId(obj, res_id)
            % getLaneIdFromResId Get the lane_id of a reservation
            % On Input:
            %   res_id: (string) the id of the reservation
            % On Output:
            %   lane_id: (string or an empty table) if the reservation id
            %       is present, then the lane_id is returned, otherwise it
            %       returns an empty table (this can be tested via:
            %           isempty(lane_id).
            % Call:
            %   lane_id = lbsd.getLaneIdFromResId("1")
            %   res_found = ~isempty(lane_id)
            lane_id = obj.reservations{...
                find(obj.reservations.id == res_id,1),'lane_id'};
        end
        
        function clearReservations(obj)
            % clearReservations Clear all reservations
            obj.reservations = table( 'Size',[obj.preallocate 7], ...
                'VariableNames', {'id','lane_id','uas_id', ...
                'entry_time_s', 'exit_time_s', 'speed', 'hd'}, ...
                'VariableTypes',{'string','string','string','double','double', ...
                'double', 'double'} );
            obj.next_res_id = 1;
            obj.next_tbl_row = 1;
        end
        
        function [minx, miny, maxx, maxy] = getEnvelope(obj)
            % getEnvelope Get the bounding box for this lane system
            %	This method returns the bounding box for the lane system
            %   On Output:
            %       minx - float (m) minimum x
            %       miny - float (m) minimum y
            %       maxx - float (m) maximum x
            %       maxy - float (m) maximum y
            %   Call:
            %       [minx, miny, maxx, maxy] = lbsd.getEnvelope()
            minx = min(obj.lane_graph.Nodes.XData);
            miny = min(obj.lane_graph.Nodes.YData);
            maxx = max(obj.lane_graph.Nodes.XData);
            maxy = max(obj.lane_graph.Nodes.YData);
        end
        
        function [ok, res_ids, res_toa_s] = ...
                reserveLBSDTrajectory(obj, lane_ids, uas_id, toa_s, ...
                h_d, r_e, r_l)
            % reserveLBSDTrajectory Reseave a sequence of lanes
            %	This method takes lane ids, time-of-arrival and departure
            %	for each lane, required headway distance, earliest launch
            %	time, and latest launch time, and returns an array of
            %	reservation ids and reserved time-of-arrival and
            %	departures.
            %   On Input:
            %       lane_ids - [nx1] string of lane identifiers
            %       uas_id - string the UAS identifier
            %       toa_s - [(n+1)x1] float seconds arrival at each vertex
            %       h_d - float headway distance in meters
            %       r_e - float seconds earliest release (launch) time 
            %           desired
            %       r_l - float seconds latest release (launch) time
            %           desired
            %   On Output:
            %       res_ids - [nx1] string reservation ids for each lane
            %       res_toa_s - [(nx1)x1] float seconds reserved arrival at
            %           at each vertex in the reserved lane sequence
            %       ok - true if the flight was successfully scheduled
            %   Call:
            %       [ok, res_ids, res_toa_s] = ...
            %               lbsd.reserveLBSDTrajectory(["1"], [1,5], ...
            %                   10, 0, 10)
            ok = true;
            res_ids = [];
            res_toa_s = [];
            if size(toa_s,2) > size(toa_s,1)
                toa_s = toa_s';
            end
            % Relative time-of-arrival gives the time it takes to get to
            % each lane entry from the first.
            rel_toa_s = toa_s - toa_s(1);
            % Get all the reservations for each lane within the desired
            % intervals
            lane_dists = obj.getLaneLengths(lane_ids);
            % The average speed in the lane is the lane distance
            % divided by the time it takes to cross the lane
            lane_speeds = lane_dists ./ (toa_s(2:end)-toa_s(1:end-1));
            % Calculate the equivalent headway times required by this
            % requested reservation
            hts = h_d / lane_speeds;
            intervals = DisjointIntervals();
            num_lanes = length(lane_ids);
            reservations = obj.getReservations();
            for i = 1:num_lanes
                lane_id = lane_ids(i);
                ht_i = hts(i);
                s_i = lane_speeds(i);
                x_d = lane_dists(i);
                % Buffer the release and exit times for the purpose of
                % considering relevant reservations that may conflict with
                % this proposed trajectory
                exit_t = x_d/s_i;
                l_r_e = r_e - ht_i;
                l_r_l = r_l + ht_i;
                l_e_e = (r_e + exit_t) - ht_i;
                l_e_l = (r_l + exit_t) + ht_i;
                % Query the reservation table for all reservations that may
                % conflict. The verbosity of the following lines (grabbing
                % indexes rather than getLaneResTimeBound is due to
                % optimizations discovered during profiling.
                lane_res = obj.getLaneResInds(lane_id, l_r_e, l_r_l, ...
                    l_e_e, l_e_l);
                % For each reservation, determine intervals that conflict
                % Found it more performant to extract the table columns as
                % vectors rather than indexing into the table
                hds = reservations.hd(lane_res);
                speeds = reservations.speed(lane_res);
                entry_times = reservations.entry_time_s(lane_res);
                for res_i = 1:length(hds)
                    hd_i = hds(res_i);
                    speed_i = speeds(res_i);
                    % Calculate the maximum required headway time
                    h_t = max(hd_i/speed_i, ht_i);
                    
                    s_j = speed_i;
                    r_j = entry_times(res_i);
                    speed_ratio = r_j - (s_j - s_i)*x_d/(s_j*s_i);
                    rs = [ speed_ratio+h_t, speed_ratio-h_t, ...
                        r_j+h_t, r_j-h_t ];
                    % Adjust the conflict interval to project onto the
                    % launch time.
                    conflict_interval = [min(rs) max(rs)] - rel_toa_s(i);
                    intervals.union(conflict_interval);
                end
            end
            % Choose the time closest to the requested time-of-arrival
            % that does not conflict. 
            
            % Since the conflict intervals are disjoint, the requested
            % start time is either within an interval or not. If not, then
            % the requested start time can be assigned, otherwise we must
            % search for an available time. 
            
            % Calculate the distance to each interval
            q = intervals.intervals - toa_s(1);
            % Find the nearest endpoint of a conflict interval that
            % occurs after the requested time
            endpt_ind = find(q(:,2) > 0, 1);
            if ~isempty(endpt_ind)
                startpt = intervals.intervals(endpt_ind,1);
                % If the start of the conflict time occurs after the
                % requested launch time, then the requested launch time can
                % be accomodated.
                if startpt >= toa_s(1)
                    res_toa_s = toa_s;
                else
                    % Otherwise we have a conflict with the requested time
                    % and need to propose a new time
                    dist_fwd = q(endpt_ind,2);
                    dist_bwd = q(endpt_ind,1);
                    s = toa_s(1);
                    fwd_ok = s + dist_fwd <= r_l;
                    bwd_ok = s + dist_bwd >= r_e;
                    if fwd_ok && bwd_ok 
                        if dist_fwd <= abs(dist_bwd)
                            res_toa_s = toa_s + dist_fwd;
                        else
                            res_toa_s = toa_s + dist_bwd;
                        end
                    elseif fwd_ok && ~bwd_ok
                        res_toa_s = toa_s + dist_fwd;
                    elseif ~fwd_ok && bwd_ok
                        res_toa_s = toa_s + dist_bwd;
                    else
                        % The conflicts cover the entire feasible region,
                        % so this flight cannot be scheduled
                        res_toa_s = [];
                        res_ids = [];
                        ok = false;
                    end
                end
            else
                % All possible conflicts occur before the requested launch,
                % so the requested toa is fine.
                res_toa_s = toa_s;
            end
            
            if ok
                % conflicts resolved, so make the reservations
                res_ids = zeros(num_lanes,1);
                for i = 1:num_lanes
                    entry_time_s = res_toa_s(i);
                    exit_time_s = res_toa_s(i+1);
                    speed = lane_speeds(i);
                    [~,res_ids(i)] = obj.makeReservation(lane_ids(i), ...
                        entry_time_s, exit_time_s, speed, h_d, uas_id);
                end
            end
        end
        
        function [ok, res_id] = makeReservation(obj, lane_id, entry_time_s, ...
            exit_time_s, speed, hd, uas_id)
            %makeReservation Create a reservation
            %   This method checks that the lane_id is valid and appends a
            %   reservation to the reservation table
            %   On Input:
            %       lane_id %(string): The lane that is being reserved
            %       entry_time_s %(float): entry time from the lane in seconds 
            %       exit_time_s %(float): exit time from the lane in seconds 
            %       speed %(float): speed in m/s
            %       hd %(float): required headway distance 
            %   On Output:
            %       ok: true if the reservation was made successfully
            %       res_id: (string) reservation id. empty string if
            %       ok is false.
            %   Call:
            %       res = lbsd.makeReservation("1",0,10,10,10)
            %
            
            % First check that the lane_id exists
            if ~find(obj.edge_table.Properties.RowNames == lane_id)
                ok = false;
                res_id = "";
                error("Requested Reservation on Lane that DNE");
            else
                % Create the candidate reservation row
                res = {string(obj.next_res_id), string(lane_id), ...
                    string(uas_id), entry_time_s, exit_time_s, speed, hd};
                % No reservations in table, so go ahead and create a
                % new one.
                new_row_ind = obj.appendReservation(res);
                obj.latest_res_row = new_row_ind;
                res_id = obj.next_res_id;
                obj.next_res_id = obj.next_res_id + 1;
                ok = true;
                notify(obj, 'NewReservation');
            end
        end
        
        function lane_res = getLaneReservations(obj, lane_id)
            % getLaneReservations Get the reservations for a lane
            % On Input:
            %   lane_id: (string) the lane id
            % On Output:
            %   lane_res: a table containing reservations
            lane_res = ...
                obj.reservations(obj.reservations.lane_id == lane_id,:);
        end
        
        function inds = getLaneResInds(obj, lane_id, r_e, r_l, ...
                e_e, e_l)
            % getLaneResInds Get reservations indexes for a lane between
            % two times. This method will return all lane reservation indexes for
            % a lane_id that are in the time range ([r_e,r_l] | [e_e,e_l])
            % On Input:
            %   lane_id: (string) the lane id
            %   r_e: (float) earliest release time in seconds to consider
            %   r_l: (float) latest release time in seconds to consider
            %   e_e: (float) earliest exit time in seconds to consider
            %   e_l: (float) latest exit time in seconds to consider
            % On Output:
            %   lane_res: an array of table indexes where the conditions are
            %   true 
            inds = obj.reservations.lane_id == lane_id & ...
                obj.reservations.entry_time_s >= r_e & ...
                obj.reservations.exit_time_s <= e_l;
        end

        function lane_res = getLaneResTimeBound(obj, lane_id, r_e, r_l, ...
                e_e, e_l)
            % getLaneResTimeBound Get the reservations for a lane between
            % two times. This amethod will return all lane reservations for
            % a lane_id that are in the time range ([r_e,r_l] | [e_e,e_l])
            % On Input:
            %   lane_id: (string) the lane id
            %   r_e: (float) earliest release time in seconds to consider
            %   r_l: (float) latest release time in seconds to consider
            %   e_e: (float) earliest exit time in seconds to consider
            %   e_l: (float) latest exit time in seconds to consider
            % On Output:
            %   lane_res: a table containing reservations
            c1 = obj.reservations.lane_id == lane_id;
            c2 = obj.reservations.entry_time_s >= r_e & ...
                    obj.reservations.entry_time_s <= r_l;
            c3 = obj.reservations.exit_time_s >= e_e & ...
                    obj.reservations.exit_time_s <= e_l;
            c = c1 & (c2 | c3);
            lane_res = obj.reservations(c, :);
        end
        
        function genRandReservations(obj, start_time, end_time, num_res, ...
                lane_ids, speed, headway)
            % genRandReservations create some random reservations
            % On Input:
            %   start_time: (float) the earliest reservation in seconds
            %   end_time: (float) the latest reservation in seconds
            %   num_res: (integer) the total number of reservations to try.
            %       Note: The final number of successful reservations may be
            %       less due to headway constraints.
            %   lane_ids: nx1 string array of lane ids to schedule on
            %   speed: (float) m/s
            %   headway: (float) m
            hd = headway;
            lengths = obj.getLaneLengths(lane_ids);
            entry_times = start_time + ...
                (end_time-start_time)*rand(1, num_res);
            for lane = lane_ids
                for res = 1:num_res
                    l = lengths(lane_ids==lane);
                    exit_time = entry_times(res)+l/speed;
                    [ok, ~] = obj.makeReservation(lane, entry_times(res), ...
                        "1", exit_time, speed, hd);
                end
            end
        end
        
              
        %% Spatial Network measures
%        bc = LEM_SNM_betweenness_centrality_node(obj,use_roads)
      %  cc = LEM_SNM_closeness_centrality(obj,use_roads)
        [acc,avg_acc] = LEM_SNM_accessibility(obj)
        alpha_index = LEM_SNM_alpha_index(obj)
        c = LEM_SNM_cyclomatic_num(obj)
        coefs = LEM_SNM_clustering_coefs(obj)
        [cost_L_T,cost_L_MST,cost] = LEM_SNM_cost_L_T(obj)
        degrees = LEM_SNM_degree(obj, use_roads)
        density = LEM_SNM_density(obj)
        detour_index = LEM_SNM_detour_index(obj)
        e = LEM_SNM_efficiency(obj)
        gamma_index = LEM_SNM_gamma_index(obj)
        diameter = LEM_SNM_graph_diameter(obj)
        r_n = LEM_SNM_r_n(obj)
        total_length = LEM_SNM_total_length(obj)
        
        %% Lane Methods
            
        function set.lane_graph(obj, g)
                % set.lane_graph Set the lane_graph property
            % 	In addition to checking all the required columns are there,
            % 	this method generates delauney triagulations for land and
            % 	launch nodes.
            % On Input:
            %   g - the lane graph - a directed graph
            has_x = any(startsWith(strtrim(...
                g.Nodes.Properties.VariableNames), 'XData'));
            has_y = any(startsWith(strtrim(...
                g.Nodes.Properties.VariableNames), 'YData'));
            has_z = any(startsWith(strtrim(...
                g.Nodes.Properties.VariableNames), 'ZData'));
            has_land = any(startsWith(strtrim(...
                g.Nodes.Properties.VariableNames), 'Land'));
            has_launch = any(startsWith(strtrim(...
                g.Nodes.Properties.VariableNames), 'Launch'));
            
            if ~has_x
                error('lane_graph must have XData column');
            end
            if ~has_y
                error('lane_graph must have YData column');
            end
            if ~has_z
                error('lane_graph must have ZData column');
            end
            if ~has_land
                error('lane_graph must have Land column');
            end
            if ~has_launch
                error('lane_graph must have Launch column');
            end
            
            obj.lane_graph = g;
            obj.recalcInternalStructs();
        end
        
        function h = plot(obj)
            %plot Plot the Lane System
            xdata = obj.lane_graph.Nodes.XData;
            ydata = obj.lane_graph.Nodes.YData;
            zdata = obj.lane_graph.Nodes.ZData;
            h = plot(obj.lane_graph,'XData',xdata,'YData',ydata, ...
                'ZData',zdata);
            
            h.NodeColor = 'k';
            h.EdgeColor = 'k';
            h.LineWidth = 2;
            axis equal
            xlabel('X(m)','FontWeight','bold');
            ylabel('Y(m)','FontWeight','bold');
            zlabel('Z(m)','FontWeight','bold');
            
        end

        function h = plot_roads(obj)
            %plot Plot the Roads of the Lane System
            xdata = obj.road_graph.Nodes.XData;
            ydata = obj.road_graph.Nodes.YData;
            zdata = obj.road_graph.Nodes.ZData;
            h = plot(obj.road_graph,'XData',xdata,'YData',ydata, ...
                'ZData',zdata);
            
            h.NodeColor = 'k';
            h.EdgeColor = 'k';
            h.LineWidth = 2;
            axis equal
            xlabel('X(m)','FontWeight','bold');
            ylabel('Y(m)','FontWeight','bold');
            zlabel('Z(m)','FontWeight','bold');
            
        end

        function h = plotLaneDiagram(obj, lane_id, plot_hd)
            if nargin < 3
                plot_hd = false;
            end
            lane_res = obj.getLaneReservations(lane_id);
            if isempty(lane_res)
                h = [];
                return;
            end
            num_res = size(lane_res,1);
            cdata = jet(num_res);
            earliest_entry = min(lane_res.entry_time_s);
            latest_exit = max(lane_res.exit_time_s);
            num_pts = round(latest_exit - earliest_entry)*100;
            t0 = earliest_entry-10;
            tf = latest_exit+10;
            t = linspace(t0, tf, num_pts);
            xd = obj.getLaneLengths(lane_id);
            h = [];
            
            colos = ['k';'b'];
            for i = 1:size(lane_res,1)
                res = lane_res(i,:);
                x = res.speed*(t-res.entry_time_s);
                h1 = x - res.hd;
                h2 = x + res.hd;
                co = colos(mod(i,2)+1);
                if i == 1
                    if plot_hd
                        h = plot(t,x,'-',t,h1,'--',t,h2,'--','Color',cdata(i,:));
                    else
                        h = plot(t,x,'--','Color',cdata(i,:));
                    end
                else
                    hold on;
                    if plot_hd
                        plot(t,x,'-',t,h1,'--',t,h2,'--','Color',cdata(i,:));
                    else
                        plot(t,x,'--','Color',cdata(i,:));
                    end
                    hold off;
                end
                hold on;
                text(res.entry_time_s,0,res.id);
                hold off;        
            end
            ylim([0,xd])
            xlim([t0-10,tf+10])
            xlabel('t(s)');
            ylabel('X(m)');
        end
        
        function h = plotLaneDiagram2(obj, lane_id)
            lane_res = obj.getLaneReservations(lane_id);
            if isempty(lane_res)
                h = [];
                return;
            end
            earliest_entry = min(lane_res.entry_time_s);
            latest_exit = max(lane_res.exit_time_s);
            num_pts = round(latest_exit - earliest_entry)*100;
            t0 = earliest_entry-10;
            tf = latest_exit+10;
            t = linspace(t0, tf, num_pts);
            xd = obj.getLaneLengths(lane_id);
            h = [];
            
            colos = ['r';'g';'k'];
            for i = 1:size(lane_res,1)
                res = lane_res(i,:);
                x = res.speed*(t-res.entry_time_s);
                h1 = x - res.hd;
                h2 = x + res.hd;
                co = colos(mod(i,2)+1);
                if i == 1
                    h = plot(t,x,'k','LineWidth',2);
                    hold on
                    p = patch([ t fliplr(t) ], [h1 fliplr(h2)], co, 'FaceAlpha',.2);
                     hp = hatchfill(p,'speckle',15,.1);
                     set(hp,'color',co,'linewidth',2);
%                     hp = hatchfill(p,'cross',30*i,3);
%                     set(hp,'color',co,'linewidth',.01);
                    hold off
                else
                    hold on;
                    h = plot(t,x,'k','LineWidth',2);
                    p = patch([ t fliplr(t) ], [h1 fliplr(h2)], co, 'FaceAlpha',.2);
%                     hp = hatchfill(p,'cross',30*i,6);
%                     set(hp,'color',co,'linewidth',.1);
                    hp = hatchfill(p,'speckle',15,.1);
                     set(hp,'color',co,'linewidth',2);
                    hold off;
                end
                hold on;
                text(res.entry_time_s,0,res.id);
                hold off;        
            end
            ylim([0,xd])
            xlim([t0-10,tf+10])
            xlabel('t(s)');
            ylabel('X(m)');
        end
        
        function highlight(obj, h, lane_ids, varargin)
            % highlight Highlight lanes in plotted graph
            % On Input:
            %   h - plot handle returned from LBSD.plot
            %   lane_ids - (nx1 string array) lane_ids
            %   varargin - (optional) variable arguments passed directly to
            %       matlab's highlight method
            %   (see
            %   https://www.mathworks.com/help/matlab/ref/...
            %   matlab.graphics.chart.primitive.graphplot.highlight.html)
            
            inds = find(ismember(...
                obj.lane_graph.Edges.Properties.RowNames, lane_ids));
            highlight(h,'Edges',inds,varargin{:});
        end
        
        function ids = getClosestLaunchVerts(obj, q)
            % getClosestLaunchVerts Get the Vertex IDs of the closest
            % launch 
            % nodes. 
            % On Input:
            %   q - nx2 query points. Each row is [x,y]
            % On Output:
            %   ids - (nx1 string array) ids of the closest launch vertex
            % Call:
            %   ids = lbsd.getClosestLaunchVerts([0 0; 5 5; -30 -15])
            xi = [];
            if ~isempty(obj.launch_delauney_tri.ConnectivityList)
                % The delauney triagulation was calculated successfully
                xi = nearestNeighbor(obj.launch_delauney_tri, q);
            else
                % Fall back to un-optimized approach
%                 P = obj.launch_table{:, {'XData','YData'}};
                P = [obj.launch_table.XData,obj.launch_table.YData];
                num_query = size(q,1);
                xi = zeros(1,num_query);
                for i = 1:num_query
                    t = P-q(i,:);
                    t = t(:,1).^2 + t(:,2).^2;
                    [~,min_i] = min(t);
                    xi(i) = min_i;
                end
            end
            ids = string(obj.launch_table.Properties.RowNames(xi));
        end
        
        function ids = getClosestLandVerts(obj, q)
            % getClosestLandVerts Get the Vertex IDs of the closest land
            % nodes. 
            % On Input:
            %   q - nx2 query points. Each row is [x,y]
            % On Output:
            %   ids - (nx1 string array) ids of the closest launch vertex
            % Call:
            %   ids = lbsd.getClosestLandVerts([0 0; 5 5; -30 -15])
            xi = [];
            if ~isempty(obj.launch_delauney_tri.ConnectivityList)
                xi = nearestNeighbor(obj.land_delauney_tri, q);
            else
                % Fall back to un-optimized approach
                P = [obj.land_table.XData, obj.land_table.YData];
                num_query = size(q,1);
                xi = zeros(1,num_query);
                for i = 1:num_query
                    t = P-q(i,:);
                    t = t(:,1).^2 + t(:,2).^2;
                    [~,min_i] = min(t);
                    xi(i) = min_i;
                end
            end
            ids = string(obj.land_table.Properties.RowNames(xi));
        end
        
%         function [lane_ids, vert_ids, dist] = getShortestPath(obj, ...
%                 start_vert_id, end_vert_id)
%             % getShortestPath Get a shortest path between two vertexes 
%             % On Input:
%             %   start_vert_id - (string) the id of the start vertex
%             %   end_vert_id - (string) the id of the end vertex
%             % On Output:
%             %   lane_ids - (nx1 string array) ids of lanes from start to
%             %       end.
%             %   vert_ids - (nx1 string array) ids of the vertexes from
%             %       start to end
%             %   distance - the distance covered by the path
%             % Call:
%             %   [lane_ids, vert_ids, dist] = lbsd.getShortestPath("12","22")
%             [vert_ids,dist,lane_ids] = shortestpath(obj.lane_graph, ...
%                 start_vert_id, end_vert_id);
%             lane_ids = string(obj.edge_table.Properties.RowNames(...
%                 lane_ids));
%             vert_ids = vert_ids';
%         end
        
        function [lane_ids, vert_ids, dist] = getShortestPath(obj, ...
                start_vert_id, end_vert_id)
            % getShortestPath Get a shortest path between two vertexes 
            % On Input:
            %   start_vert_id - (string) the id of the start vertex
            %   end_vert_id - (string) the id of the end vertex
            % On Output:
            %   lane_ids - (nx1 string array) ids of lanes from start to
            %       end.
            %   vert_ids - (nx1 string array) ids of the vertexes from
            %       start to end
            %   distance - the distance covered by the path
            % Call:
            %   [lane_ids, vert_ids, dist] = lbsd.getShortestPath("12","22")
            start_vert_ind = ...
                find(obj.node_table.Properties.RowNames==start_vert_id);
            end_vert_ind = ...
                find(obj.node_table.Properties.RowNames==end_vert_id);
            cached = obj.path_cache(start_vert_ind, end_vert_ind);
            if cached
                path_data = obj.path_cache_map(full(cached));
                vert_ids = path_data.vert_ids;
                dist = path_data.dist;
                lane_ids = path_data.lane_ids;
            else
                [vert_ids,dist,lane_ids] = shortestpath(obj.lane_graph, ...
                    start_vert_id, end_vert_id);
                lane_ids = string(obj.edge_table.Properties.RowNames(...
                    lane_ids));
                vert_ids = vert_ids';
                path_data.vert_ids = vert_ids;
                path_data.dist = dist;
                path_data.lane_ids = lane_ids;
                next_ind = length(obj.path_cache_map)+1;
                obj.path_cache_map = [obj.path_cache_map path_data];
                obj.path_cache(start_vert_ind,end_vert_ind) = next_ind;
            end
        end
        
        function ids = getLaunchVerts(obj)
            % getLaunchVerts Get the Vertex IDs of the launch nodes
            % On Output:
            %   ids - indices of vertexes
            ids = string(obj.launch_table.Properties.RowNames);
        end
        
        function ids = getLandVerts(obj)
            % getLandVerts Get the Vertex IDs of the land nodes
            % On Output:
            %   ids - string array
            ids = string(obj.land_table.Properties.RowNames);
        end
        
        function positions = getVertPositions(obj, ids)
            % getVertPositions Get the Positions of Vertexes in the lane 
            %   system by ID
            % On Input:
            %   ids - nx1 string array or ':' for all
            % On Output:
            %   positions - nx3 positions of vertexes
            rows = ismember(obj.node_table.Properties.RowNames, ids);
            x = obj.node_table.XData(rows);
            y = obj.node_table.YData(rows);
            z = obj.node_table.ZData(rows);
%             positions = obj.node_table{ids,{'XData','YData','ZData'}};
            positions = [x y z];
        end
        
        function ids = getLaneVertexes(obj, lane_id)
            % getLaneVertexes Get the vertex ids that define the lane
            % endpoints.
            % On Input:
            %   lane_id - (string) the id of the lane
            % On Output:
            %   ids - 2x1 string array of endpoint vertex ids
            ids = obj.edge_table.EndNodes(...
                ismember(obj.edge_table.Properties.RowNames,lane_id),:);
%             ids = obj.edge_table{lane_id,{'EndNodes'}}';
%             ids = obj.node_table.Properties.RowNames
%             ids = string(obj.node_table(rows,:).Properties.RowNames);
        end
        
        function lane_ids = getLaneIds(obj)
            % getLaneIds Get the lane ids in the system
            % endpoints.
            % On Output:
            %   lane_ids - nx1 vector of strings of lane ids
            lane_ids = obj.edge_table.Properties.RowNames;
            lane_ids = string(lane_ids);
        end
        
        function lengths = getLaneLengths(obj, lane_ids)
            % getLaneLengths Get the langths of lanes
            % On Input:
            %   lane_ids - nx1 (strings) the ids of the lanes
            % On Output:
            %   length - nx1 vector of floats of distances
            % Call:
            %   lengths = lbsd.getLaneLengths(["1","2"])
            
            lengths = obj.edge_table.Weight(...
                obj.edge_table.Properties.RowNames(lane_ids));
        end
        
        function recalcInternalStructs(obj)
            % recalcInternalStructs Recalculate internal structures
            %   This function recalculates internal structures like land
            %   and launch tables and delauney triangulations. This
            %   method should be called anytime the lane_graph is modified.
            
            % Create shortest path cache
            s_sz = size(obj.lane_graph.adjacency);
            obj.path_cache = sparse(s_sz(1),s_sz(2));
            
            obj.recalcLaunchTable();
            obj.recalcLandTable();
            obj.recalcLaunchDelauney();
            obj.recalcLandDelauney();
            obj.recalcEdgeTable();
            obj.recalcNodeTable();
        end
        
        f = LEM_SNM_route_factor(obj)
        ds = LEM_SNM_min_path_step(obj,G)
        dd = LEM_SNM_min_path_dist(obj,G)
        A = LEM_SNM_adjacency_matrix(obj)
        airways_out = LEM_gen_lanes(obj,airways)
        [r_up,r_dn] = LEM_roundabout(obj,airways,v)
        ptheta = LEM_posori(obj,theta)
        pts_out = LEM_elim_redundant(obj,pts)
        G = LEM_airways2graph(obj,airways)
        airways_out = LEM_add_ground_height(obj,airways)
        LEM_show_airways3D(obj,airways,path)
        t = LEM_launch_time_nc(obj,reservations,path,t1,t2,lane_lengths,hd,...
            speed)
        excluded_out = LEM_excluded(obj,excluded,t1,t2,ft1,ft2,ht)
        new_int = LEM_merge_excluded(obj,t1,t2,int1,int2)
        lanes = LEM_vertexes2lanes(obj,airways,indexes)
        [path,v_path] = LEM_get_path(obj,airways,v1,v2,props)
        [reservations_out,flights] = LEM_gen_reservations(obj,airways,...
            a_flights,reservations,request,n,hd)
        requests = LEM_gen_requests_packed(obj,t_min,t_max,airways,...
            num_requests,del_t,speeds)
        route = LEM_plan2route(obj,plan,airways)
        requests = LEM_gen_requests_LBSD(obj,t_min,t_max,airways,...
            num_requests,launch_interval,speeds)
        P = LEM_performance(obj,flights)
        LEM_run_flights(obj,airways,flights,a_on,del_t,fname)
        flight_out = LEM_gen_traj(obj,flight,del_t)
        [reservations,flights] = LEM_requests2reservations(obj,airways,...
            requests,hd)
        [flight_plan,reservations] = LEM_reserve_fp(obj,reservations,...
            airways,t1,t2,speed,path,hd)
        res = LEM_sim1_LBSD_51x51(obj,num_flights,airways,t_min,t_max,...
            launch_time_spread,b)
        indexes = LEM_find_conflict(obj,reservations,ht)
        bc = LEM_SNM_betweenness_centrality_node(obj,use_roads)
        cc = LEM_SNM_closeness_centrality(obj,use_roads)
        sc = LEM_SNM_straightness_centrality(obj,use_roads)
        airways = LEM_gen_airways(obj, roads,launch_sites,land_sites,...
            min_lane_len,altitude1,altitude2)
    end
    
    methods (Access = protected)
        function row_ind = appendReservation(obj, row)
            % appendReservation Append to the reservations table
            % On Input:
            %   row - cell array containing the reservation 
            % On Output:
            %   row_ind - the index of the new row in the reservations
            %   table.
            if obj.next_tbl_row < obj.preallocate
                obj.reservations(obj.next_tbl_row, :) = row;
                row_ind = obj.next_tbl_row;
                obj.next_tbl_row = obj.next_tbl_row + 1;
            else
                if ~obj.notified_preallocation_warning
                    warning("Exhausted Preallocated Reservations, Performance will now suffer");
                    obj.notified_preallocation_warning = true;
                end
                obj.reservations = [obj.reservations; row];
                row_ind = obj.next_tbl_row;
                obj.next_tbl_row = obj.next_tbl_row + 1;
            end
        end
        
                
        function recalcLaunchDelauney(obj)
            % recalcLaunchDelauney Recalculate the delauney triangulation
            % for launch nodes
            P = obj.launch_table{:, {'XData','YData'}};
            obj.launch_delauney_tri = delaunayTriangulation(P);
        end
        
        function recalcLandDelauney(obj)
            % recalcLandDelauney Recalculate the delauney triangulation
            % for land nodes
            P = obj.land_table{:, {'XData','YData'}};
            obj.land_delauney_tri = delaunayTriangulation(P);
        end
        
        function recalcEdgeTable(obj)
            % For optimization reasons keep a cached edge table in memory
           obj.edge_table = obj.lane_graph.Edges; 
        end
        
        function recalcNodeTable(obj)
            % For optimization reasons keep a cached edge table in memory
           obj.node_table = obj.lane_graph.Nodes; 
        end
        
        function recalcLaunchTable(obj)
            % recalcLaunchTable Recalculate the launch node table
            obj.launch_table = obj.lane_graph.Nodes(...
                obj.lane_graph.Nodes.Launch==1,:);
        end
        
        function recalcLandTable(obj)
            % recalcLandTable Recalculate the land node table
            obj.land_table = obj.lane_graph.Nodes(...
                obj.lane_graph.Nodes.Land==1,:);
        end
        
    end
    
    methods (Static)
        lbsd = genSampleLanes(lane_length_m, altitude_m)
        lbsd = genSimpleLanes(lane_lengths_m)
        
        lane_graph = airways2lanegraph(airways)
        
        
        [t, lbsd] = LEM_test_res(use_class)

        lbsd = LEM_gen_grid_roads(xmin,xmax,ymin,ymax,dx,dy)
        
        lbsd = LEM_gen_Delaunay_roads(xmin,xmax,ymin,ymax,num_ver,min_dist)
        
        function [H, f] = genReleaseObjective(rd)
            % genReleaseObjective Generate quadprog objective parameters
            % This is a quadratic objective that minimizes the time
            % distance between the desired release time and the constrained
            % solution.
            % On Input:
            %   rd - (float) desired release time
            % On Output:
            %   H - The H matrix for quadprog
            %   f - the f vector for quadprog
            % Call:
            %   [H, f] = genReleaseObjective(rd)
            H = [2 0; 0 0];
            f = [-2*rd 0]';
        end
        
        function [A, b] = genConflictConstraints(s, si, ri, ht, x0, xd)
            % https://optimization.cbe.cornell.edu/index.php?title=Optimization_with_absolute_values
            % genConflictConstraints Generate quadprog constraints for pair
            % conflict. It is assumed that the x vector is [x,r]', where x
            % is the position along a lane and r is the release time of the
            % desired reservation
            % On Input:
            %   s - (float) speed of the desired reservation
            %   si - (float) speed of the scheduled reservation
            %   ri - (float) release time of the scheduled reservation
            %   ht - (float) headway time required
            %   x0 - (float) start position (usually zero)
            %   xd - (float) end position (usually length of lane)
            % On Output:
            %   A - The A matrix for quadprog
            %   b - the b vector for quadprog
            % Call:
            %   [A, b] = LBSD.genConflictConstraints(s, si, ri, ht, x0, xd)
            A = [ -1/s  (s-si)/(s*si) ; ...
                   1/s  (si-s)/(s*si) ; ...
                   0    1;   ...
                   0   -1; ];
            b = [ -ht-(ri/si), -ht+(ri/si), xd, -x0 ]'; 
        end
    end
end
